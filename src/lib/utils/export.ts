import { Buffer } from 'buffer'
import { PDFDocument } from 'pdf-lib'
import * as XLSX from 'xlsx'

interface ContactExport {
  id: string
  full_name: string
  email: string
  phone: string
  company: string
  title: string
  status: string
  interest_level: string
  investment_range: string
  created_at: string
  updated_at: string
  notes: string
  last_contacted?: string
  source?: string
  tags?: string[]
  custom_fields?: Record<string, any>
  [key: string]: any
}

interface PartialContactExport {
  [key: string]: any
}

export interface ExportOptions {
  format: 'csv' | 'pdf' | 'xlsx' | 'json'
  filename?: string
  include?: string[]
  exclude?: string[]
  maxRecords?: number
  batchSize?: number
  progressCallback?: (progress: number, total: number) => void
  validate?: {
    required?: string[]
    email?: string[]
    phone?: string[]
    date?: string[]
    investment?: string[]
  }
  filters?: {
    status?: string[]
    interest?: string[]
    investment?: string[]
    tags?: string[]
    custom?: Record<string, any>
  }
  sort?: {
    field: string
    direction: 'asc' | 'desc'
  }[]
  search?: string
}

export async function generateCSV(data: ContactExport[], options: ExportOptions) {
  // Filter columns based on include/exclude
  const columns = filterColumns(Object.keys(data[0]), options)
  const filteredData = data.map(row => pick(row, columns))

  const ws = XLSX.utils.json_to_sheet(filteredData)
  const wb = XLSX.utils.book_new()
  XLSX.utils.book_append_sheet(wb, ws, "Contacts")

  // Create buffer
  const buffer = XLSX.write(wb, {
    type: 'buffer',
    bookType: 'csv',
    bookSST: true
  })

  return {
    filename: `${options.filename || 'contacts'}.csv`,
    contentType: 'text/csv',
    buffer
  }
}

export async function generatePDF(data: ContactExport[], options: ExportOptions) {
  if (data.length > 1000) {
    throw new Error('PDF export is limited to 1000 records for performance reasons')
  }

  const pdfDoc = await PDFDocument.create()

  // Add a page
  const page = pdfDoc.addPage()
  const { width, height } = page.getSize()

  // Add title
  const titleFont = await pdfDoc.embedFont('Times-Roman')
  page.drawText('Luxe Queer Magazine CRM Report', {
    x: 50,
    y: height - 50,
    size: 24,
    font: titleFont
  })

  // Add date
  const date = new Date().toLocaleDateString()
  const dateFont = await pdfDoc.embedFont('Times-Roman')
  page.drawText(date, {
    x: width - 150,
    y: height - 50,
    size: 12,
    font: dateFont
  })

  // Filter columns based on include/exclude
  const columns = filterColumns(Object.keys(data[0]), options)
  const filteredData = data.map(row => pick(row, columns))

  // Add table header
  const headerFont = await pdfDoc.embedFont('Times-Bold')
  const headers = columns
  const headerHeight = height - 100
  const cellWidth = width / headers.length

  headers.forEach((header, index) => {
    page.drawText(header.replace('_', ' '), {
      x: 50 + (index * cellWidth),
      y: headerHeight,
      size: 12,
      font: headerFont
    })
  })

  // Add table data
  const dataFont = await pdfDoc.embedFont('Times-Roman')
  filteredData.forEach((row, rowIndex) => {
    const rowHeight = headerHeight - (rowIndex + 1) * 20
    Object.entries(row).forEach(([key, value], colIndex) => {
      page.drawText(String(value), {
        x: 50 + (colIndex * cellWidth),
        y: rowHeight,
        size: 10,
        font: dataFont
      })
    })
  })

  // Add footer
  const footerFont = await pdfDoc.embedFont('Times-Roman')
  page.drawText('Generated by Luxe Queer Magazine CRM', {
    x: 50,
    y: 50,
    size: 10,
    font: footerFont
  })

  const pdfBytes = await pdfDoc.save()
  return {
    filename: `${options.filename || 'contacts'}.pdf`,
    contentType: 'application/pdf',
    buffer: Buffer.from(pdfBytes)
  }
}

export async function generateReport(data: ContactExport[], options: ExportOptions) {
  // Validate options
  if (!['csv', 'pdf', 'xlsx', 'json'].includes(options.format)) {
    throw new Error(`Invalid format: ${options.format}. Must be one of: csv, pdf, xlsx, json`)
  }

  // Handle large exports and batch processing
  const batchSize = options.batchSize || 1000
  const totalRecords = data.length
  let processedRecords = 0

  // Filter columns based on include/exclude
  const columns = filterColumns(Object.keys(data[0]), options)

  // Apply filters
  let filteredData = data
  if (options.filters) {
    filteredData = filteredData.filter(record => {
      const matchesStatus = !options.filters.status || (options.filters.status && options.filters.status.includes(record.status))
      const matchesInterest = !options.filters.interest || (options.filters.interest && options.filters.interest.includes(record.interest_level))
      const matchesInvestment = !options.filters.investment || (options.filters.investment && options.filters.investment.includes(record.investment_range))
      const matchesTags = !options.filters.tags || (options.filters.tags && options.filters.tags.some(tag => record.tags?.includes(tag) || false))

      // Custom field filtering
      let matchesCustom = true
      if (options.filters?.custom) {
        matchesCustom = Object.entries(options.filters.custom).every(([field, value]) => {
          const customField = record.custom_fields?.[field]
          return customField !== undefined && customField === value
        })
      }

      return matchesStatus && matchesInterest && matchesInvestment && matchesTags && matchesCustom
    })
  }

  // Search functionality
  if (options.search) {
    const searchTerms = options.search.toLowerCase()
    filteredData = filteredData.filter(record => {
      return Object.values(record).some(value => {
        if (typeof value === 'string') {
          return value.toLowerCase().includes(searchTerms)
        }
        return false
      })
    })
  }

  // Sorting
  if (options.sort) {
    options.sort.forEach(sort => {
      filteredData.sort((a, b) => {
        const aValue = a[sort.field]
        const bValue = b[sort.field]

        if (typeof aValue === 'string' && typeof bValue === 'string') {
          return sort.direction === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue)
        }
        if (typeof aValue === 'number' && typeof bValue === 'number') {
          return sort.direction === 'asc' ? aValue - bValue : bValue - aValue
        }
        return 0
      })
    })
  }

  // Handle large exports and batch processing
  const batches = Math.ceil(filteredData.length / batchSize)
  let result: any[] = []

  for (let i = 0; i < batches; i++) {
    const start = i * batchSize
    const end = Math.min(start + batchSize, filteredData.length)
    const batch = filteredData.slice(start, end)

    // Validate batch
    if (options.validate) {
      const validationErrors: Record<string, string[]> = {}

      // Required fields
      if (options.validate.required) {
        batch.forEach((record, index) => {
          options.validate.required.forEach(field => {
            if (field in record && (!record[field] || record[field] === '')) {
              validationErrors[`${field}_${index}`] = ['This field is required']
            }
          })
        })
      }

      // Email validation
      if (options.validate.email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        batch.forEach((record, index) => {
          options.validate.email.forEach(field => {
            if (field in record && record[field] && typeof record[field] === 'string' && !emailRegex.test(record[field])) {
              validationErrors[`${field}_${index}`] = ['Invalid email format']
            }
          })
        })
      }

      // Phone validation
      if (options.validate.phone) {
        const phoneRegex = /^[\d\s-]+$/
        batch.forEach((record, index) => {
          options.validate.phone.forEach(field => {
            if (field in record && record[field] && typeof record[field] === 'string' && !phoneRegex.test(record[field])) {
              validationErrors[`${field}_${index}`] = ['Invalid phone number format']
            }
          })
        })
      }

      // Date validation
      if (options.validate.date) {
        batch.forEach((record, index) => {
          options.validate.date.forEach(field => {
            if (field in record && record[field] && typeof record[field] === 'string' && isNaN(new Date(record[field]).getTime())) {
              validationErrors[`${field}_${index}`] = ['Invalid date format']
            }
          })
        })
      }

      // Investment range validation
      if (options.validate.investment) {
        batch.forEach((record, index) => {
          options.validate.investment.forEach(field => {
            if (field in record && record[field] && typeof record[field] === 'string' && isNaN(Number(record[field]))) {
              validationErrors[`${field}_${index}`] = ['Invalid investment amount']
            }
          })
        })
      }

      if (Object.keys(validationErrors).length > 0) {
        throw new Error(`Validation errors found. Please check the data and try again.`)
      }
    }

    // Process batch
    const batchResult = batch.map(row => {
      const filteredRow = pick(row, columns)
      return filteredRow
    })

    result = [...result, ...batchResult]
    processedRecords += batch.length

    // Update progress
    if (options.progressCallback) {
      options.progressCallback(processedRecords, totalRecords)
    }
  }

  // Apply maxRecords limit
  if (options.maxRecords) {
    result = result.slice(0, options.maxRecords)
  }

  // Generate final report
  switch (options.format) {
    case 'csv':
      return generateCSV(result, options)
    case 'pdf':
      return generatePDF(result, options)
    case 'xlsx':
      return generateXLSX(result, options)
    case 'json':
      return generateJSON(result, options)
    default:
      throw new Error('Invalid format specified')
  }
}

function filterColumns(allColumns: string[], options: ExportOptions): string[] {
  const includeSet = new Set(options.include || [])
  const excludeSet = new Set(options.exclude || [])

  return allColumns.filter(col => {
    if (options.include?.length) {
      return includeSet.has(col)
    }
    return !excludeSet.has(col)
  })
}

function pick(obj: PartialContactExport, keys: string[]): PartialContactExport {
  const result: PartialContactExport = {}
  keys.forEach(key => {
    if (obj.hasOwnProperty(key)) {
      result[key] = obj[key]
    }
  })
  return result
}

export async function generateXLSX(data: ContactExport[], options: ExportOptions) {
  const ws = XLSX.utils.json_to_sheet(data)
  const wb = XLSX.utils.book_new()
  XLSX.utils.book_append_sheet(wb, ws, "Contacts")

  // Create buffer
  const buffer = XLSX.write(wb, {
    type: 'buffer',
    bookType: 'xlsx',
    bookSST: true
  })

  return {
    filename: `${options.filename || 'contacts'}.xlsx`,
    contentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    buffer
  }
}

export async function generateJSON(data: ContactExport[], options: ExportOptions) {
  const buffer = Buffer.from(JSON.stringify(data, null, 2))
  return {
    filename: `${options.filename || 'contacts'}.json`,
    contentType: 'application/json',
    buffer
  }
}